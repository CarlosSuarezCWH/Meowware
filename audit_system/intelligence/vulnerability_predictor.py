"""
Vulnerability Prediction System
Predicts vulnerabilities based on detected software versions

Meowware v16.0 - Developed by Carlos Mancera
"""
from typing import Dict, List, Any, Optional
from ..core.models import Finding, Severity
from .cve_lookup import CVELookup
from ..core.debug import debug_print

class VulnerabilityPredictor:
    """
    Predicts vulnerabilities based on:
    - Detected software versions
    - Common configurations
    - Historical patterns
    - CVE databases
    """
    
    def __init__(self):
        self.cve_lookup = CVELookup()
        # Known vulnerable versions (can be expanded)
        self.vulnerable_versions = {
            "apache": {
                "2.4.49": ["CVE-2021-44224", "CVE-2021-41773"],
                "2.4.50": ["CVE-2021-44224", "CVE-2021-41773"]
            },
            "wordpress": {
                "5.0": ["XSS vulnerabilities", "SQL injection risks"],
                "4.0": ["Multiple CVEs"]
            },
            "php": {
                "7.4.0": ["CVE-2020-7069"],
                "7.3.0": ["Multiple CVEs"]
            }
        }
    
    def predict_vulnerabilities(self, tech_versions: Dict[str, str]) -> List[Dict[str, Any]]:
        """
        Predict vulnerabilities for detected technologies
        
        Args:
            tech_versions: Dictionary of {technology: version}
        
        Returns:
            List of predicted vulnerabilities with confidence scores
        """
        predictions = []
        
        for product, version in tech_versions.items():
            product_lower = product.lower()
            
            # Check known vulnerable versions
            if product_lower in self.vulnerable_versions:
                vuln_versions = self.vulnerable_versions[product_lower]
                for vuln_version, cves in vuln_versions.items():
                    if version.startswith(vuln_version) or vuln_version in version:
                        predictions.append({
                            "product": product,
                            "version": version,
                            "vulnerable_version": vuln_version,
                            "predicted_cves": cves,
                            "confidence": 0.9,
                            "source": "known_vulnerable"
                        })
            
            # Query CVE database for this version
            try:
                cve_summary = self.cve_lookup.get_cve_summary(product, version)
                
                if cve_summary["total"] > 0:
                    predictions.append({
                        "product": product,
                        "version": version,
                        "cve_count": cve_summary["total"],
                        "critical_count": cve_summary["critical"],
                        "high_count": cve_summary["high"],
                        "average_cvss": cve_summary["average_cvss"],
                        "top_cves": cve_summary["cves"],
                        "confidence": 0.8 if cve_summary["total"] > 5 else 0.6,
                        "source": "cve_database"
                    })
            except Exception as e:
                debug_print(f"  ⚠️ CVE lookup failed for {product} {version}: {e}")
        
        return predictions
    
    def generate_findings_from_predictions(self, predictions: List[Dict[str, Any]]) -> List[Finding]:
        """Convert predictions to Finding objects"""
        findings = []
        
        for pred in predictions:
            if pred["source"] == "known_vulnerable":
                title = f"Known Vulnerable Version: {pred['product']} {pred['version']}"
                description = f"Version {pred['version']} of {pred['product']} is known to have vulnerabilities: {', '.join(pred['predicted_cves'])}"
                
                findings.append(Finding(
                    title=title,
                    category="Vulnerability Prediction",
                    severity=Severity.HIGH,
                    description=description,
                    recommendation=f"Update {pred['product']} to a patched version immediately",
                    confidence_score=pred["confidence"],
                    evidence_type="HEURISTIC"
                ))
            
            elif pred["source"] == "cve_database":
                if pred["critical_count"] > 0 or pred["high_count"] > 0:
                    severity = Severity.CRITICAL if pred["critical_count"] > 0 else Severity.HIGH
                    title = f"Multiple CVEs Detected: {pred['product']} {pred['version']}"
                    description = f"Found {pred['cve_count']} CVEs for {pred['product']} {pred['version']}: "
                    description += f"{pred['critical_count']} critical, {pred['high_count']} high. "
                    description += f"Average CVSS: {pred['average_cvss']}"
                    
                    if pred["top_cves"]:
                        description += "\n\nTop CVEs:\n"
                        for cve in pred["top_cves"][:3]:
                            description += f"- {cve.get('id', 'N/A')}: {cve.get('summary', '')[:100]}...\n"
                    
                    findings.append(Finding(
                        title=title,
                        category="CVE Analysis",
                        severity=severity,
                        description=description,
                        recommendation=f"Review and patch {pred['product']} {pred['version']} - multiple CVEs identified",
                        confidence_score=pred["confidence"],
                        evidence_type="VULNERABILITY"
                    ))
        
        return findings
    
    def predict_attack_vectors(self, tech_versions: Dict[str, str], 
                              services: List) -> List[str]:
        """
        Predict potential attack vectors based on stack
        
        Returns:
            List of predicted attack vectors
        """
        vectors = []
        
        # Check for common vulnerable combinations
        has_web = any(s.port in [80, 443] for s in services if hasattr(s, 'port'))
        has_db = any(s.port in [3306, 5432] for s in services if hasattr(s, 'port'))
        
        if has_web and has_db:
            vectors.append("SQL Injection → Database Compromise")
        
        # Check for outdated PHP
        if "php" in str(tech_versions).lower():
            php_version = tech_versions.get("PHP", "")
            if php_version and php_version.startswith("7."):
                vectors.append("Outdated PHP → RCE vulnerabilities")
        
        # Check for old WordPress
        if "wordpress" in str(tech_versions).lower():
            wp_version = tech_versions.get("WordPress", "")
            if wp_version and wp_version.startswith("5."):
                vectors.append("Outdated WordPress → Plugin vulnerabilities")
        
        return vectors

