from .base_agent import BaseAgent
from ...core.models import Host
from typing import Dict, Any
import json

class ExploitAgent(BaseAgent):
    def __init__(self, model: str = None):
        super().__init__("Exploit", model)

    def run(self, host: Host, context: Dict[str, Any]) -> Dict[str, Any]:
        """
        Specialized reasoning for vulnerability chaining and exploitation.
        """
        executed_tools = context.get('history', [])
        history_str = "\n".join([f"- {t} \u2713 (YA USADO)" for t in executed_tools if t != "stop"])
        
        prompt = f"""### ROL: ExploitAgent (Exploitation & Chaining Expert)
Analiza los hallazgos críticos y sugiere el siguiente paso de EXPLOTACIÓN o VERIFICACIÓN.

### ESTADO DEL OBJETIVO:
- Host: {host.hostname} ({host.ip})
- Hallazgos Críticos: {json.dumps(context.get('recent_findings', []))}
- Resumen: {context.get('findings_summary', "")}

### HERRAMIENTAS EJECUTADAS (NO REPETIR):
{history_str if history_str else "- Ninguna"}

### ACCIONES RECOMENDADAS:
- sqlmap: Si hay evidencias de SQLi.
- wpscan: Para explotar plugins vulnerables conocidos.
- vuln_verifier: Para PoCs no destructivos.

### RESPUESTA (JSON):
{{
    "decision": {{
        "tool": "tool_name",
        "reason": "why this exploitation step is chosen",
        "params": {{ "payload": "suggested_payload", "vulnerability_id": "CVE-XXXX-XXXX" }}
    }},
    "exploitation_analysis": {{
        "likelihood_of_success": 0.0-1.0,
        "potential_impact": "High/Medium/Low",
        "chain_complexity": "High/Medium/Low"
    }}
}}
"""
        
        response_text = self._call_llm(prompt)
        if response_text:
            try:
                return json.loads(self._clean_json(response_text))
            except:
                pass
        
        return {}
