"""
MITRE ATT&CK Chain Builder
Builds complete exploitation chains following MITRE ATT&CK framework
v18.0: Graph-based probabilistic attack paths

Meowware v18.0 - Developed by Carlos Mancera
"""
from typing import List, Dict, Any, Optional
from enum import Enum
from dataclasses import dataclass, field
from datetime import datetime
from ..core.models import Host, Finding, Severity
from ..core.debug import debug_print

class ATTACKTactic(str, Enum):
    """MITRE ATT&CK Tactics"""
    RECONNAISSANCE = "Reconnaissance"
    RESOURCE_DEVELOPMENT = "Resource Development"
    INITIAL_ACCESS = "Initial Access"
    EXECUTION = "Execution"
    PERSISTENCE = "Persistence"
    PRIVILEGE_ESCALATION = "Privilege Escalation"
    DEFENSE_EVASION = "Defense Evasion"
    CREDENTIAL_ACCESS = "Credential Access"
    DISCOVERY = "Discovery"
    LATERAL_MOVEMENT = "Lateral Movement"
    COLLECTION = "Collection"
    COMMAND_AND_CONTROL = "Command and Control"
    EXFILTRATION = "Exfiltration"
    IMPACT = "Impact"

class AttackNodeType(str, Enum):
    ASSET = "Asset"
    VULNERABILITY = "Vulnerability"
    ACCESS = "Access"
    DATA = "Data"

@dataclass
class AttackNode:
    id: str
    type: AttackNodeType
    description: str
    probability: float = 0.0
    compromised: bool = False
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class AttackEdge:
    source_id: str
    target_id: str
    action: str
    probability: float
    requirements: List[str] = field(default_factory=list)

class ChainGraph:
    """Graph representing potential attack paths"""
    def __init__(self):
        self.nodes: Dict[str, AttackNode] = {}
        self.edges: List[AttackEdge] = []
    
    def add_node(self, node: AttackNode):
        self.nodes[node.id] = node
        
    def add_edge(self, source_id: str, target_id: str, action: str, prob: float):
        if source_id in self.nodes and target_id in self.nodes:
            self.edges.append(AttackEdge(source_id, target_id, action, prob))

    def get_paths(self, start_node_id: str, end_node_id: str) -> List[List[AttackEdge]]:
        # Simple DFS for paths
        paths = []
        visited = set()
        
        def dfs(current_id: str, current_path: List[AttackEdge]):
            if current_id == end_node_id:
                paths.append(list(current_path))
                return
            
            visited.add(current_id)
            
            # Find outgoing edges
            outgoing = [e for e in self.edges if e.source_id == current_id]
            for edge in outgoing:
                if edge.target_id not in visited:
                    current_path.append(edge)
                    dfs(edge.target_id, current_path)
                    current_path.pop()
            
            visited.remove(current_id)
            
        if start_node_id in self.nodes and end_node_id in self.nodes:
            dfs(start_node_id, [])
        return paths

@dataclass
class AttackStep:
    """Represents a step in the attack chain"""
    tactic: ATTACKTactic
    technique: str
    description: str
    success: bool = False
    timestamp: datetime = field(default_factory=datetime.now)
    evidence: List[str] = field(default_factory=list)
    tools_used: List[str] = field(default_factory=list)
    findings: List[Finding] = field(default_factory=list)

@dataclass
class ExploitationChain:
    """Complete exploitation chain following MITRE ATT&CK"""
    target: Host
    steps: List[AttackStep] = field(default_factory=list)
    compromised_hosts: List[Host] = field(default_factory=list)
    credentials_extracted: List[Dict[str, Any]] = field(default_factory=list)
    data_exfiltrated: List[Dict[str, Any]] = field(default_factory=list)
    impact_score: float = 0.0
    created_at: datetime = field(default_factory=datetime.now)

class MITREAttackChainBuilder:
    """
    Builds probabilistic attack chains using a graph approach.
    v18.0: Graph-based logic
    """
    
    def __init__(self):
        self.graph = ChainGraph()
    
    def build_chain(self, target: Host, findings: List[Finding]) -> ExploitationChain:
        debug_print(f"    [MITRE ATT&CK] Building dynamic attack graph for {target.hostname or target.ip}")
        
        chain = ExploitationChain(target=target)
        self.graph = ChainGraph() # Reset graph
        
        # 1. Initialize Nodes from Context
        target_id = f"host_{target.ip}"
        self.graph.add_node(AttackNode(target_id, AttackNodeType.ASSET, f"Target Host: {target.ip}", 1.0, True))
        
        db_access_id = "access_database"
        self.graph.add_node(AttackNode(db_access_id, AttackNodeType.ACCESS, "Database Access", 0.0))
        
        admin_access_id = "access_admin"
        self.graph.add_node(AttackNode(admin_access_id, AttackNodeType.ACCESS, "Admin/Root Access", 0.0))
        
        data_id = "data_sensitive"
        self.graph.add_node(AttackNode(data_id, AttackNodeType.DATA, "Sensitive Data (PII/Creds)", 0.0))

        # 2. Map Findings to Nodes/Edges
        for finding in findings:
            f_id = f"vuln_{finding.title[:10].replace(' ', '_')}_{hash(finding.title) % 1000}"
            
            # Add Vulnerability Node
            confidence = getattr(finding, 'confidence_score', 0.5)
            self.graph.add_node(AttackNode(f_id, AttackNodeType.VULNERABILITY, finding.title, confidence, True))
            
            # Link Host -> Vuln (The vuln exists on the host)
            self.graph.add_edge(target_id, f_id, "Exposes", 1.0)
            
            # Link Vuln -> Capabilities (The "Chaining" logic)
            title_lower = finding.title.lower()
            desc_lower = finding.description.lower()
            
            # SQL Injection Logic
            if 'sql' in title_lower or 'sqli' in title_lower:
                # SQLi -> DB Access
                prob = 0.8 if 'confirmed' in desc_lower else 0.5
                self.graph.add_edge(f_id, db_access_id, "Exploit SQLi", prob)
            
            # RCE / Command Injection
            if 'rce' in title_lower or 'command injection' in title_lower or 'remote code' in title_lower:
                # RCE -> Admin Access
                prob = 0.9
                self.graph.add_edge(f_id, admin_access_id, "Execute Arbitrary Code", prob)
                
            # Weak Creds / Default Creds
            if 'default cred' in title_lower or 'weak password' in title_lower:
                # Weak Creds -> Admin Access
                self.graph.add_edge(f_id, admin_access_id, "Login with extracted creds", 1.0)

            # XSS 
            if 'xss' in title_lower:
                 # XSS -> Admin Access (via cookie steal)
                 self.graph.add_edge(f_id, admin_access_id, "Steal Session Cookies", 0.3)

        # 3. Add Internal Logic Edges (PrivEsc, Lateral)
        # DB Access -> Sensitive Data
        self.graph.add_edge(db_access_id, data_id, "Dump Database", 0.9)
        
        # Admin Access -> Sensitive Data
        self.graph.add_edge(admin_access_id, data_id, "Access Filesystem", 1.0)
        
        # DB Access -> Admin Access (Reuse creds)
        self.graph.add_edge(db_access_id, admin_access_id, "Credential Reuse", 0.4)

        # 4. Calculate Paths & Build Chain Object
        objectives = [admin_access_id, data_id]
        
        found_paths = False
        for obj_id in objectives:
            paths = self.graph.get_paths(target_id, obj_id)
            if paths:
                debug_print(f"      âœ“ Found {len(paths)} attack paths to {obj_id}")
                # Choose best path
                best_path = max(paths, key=lambda p: self._calculate_path_prob(p))
                
                # Convert logic to steps
                for edge in best_path:
                    if edge.action == "Exposes": continue
                    
                    tactic = ATTACKTactic.LATERAL_MOVEMENT # Default
                    if "Exploit" in edge.action: tactic = ATTACKTactic.INITIAL_ACCESS
                    elif "Dump" in edge.action: tactic = ATTACKTactic.COLLECTION
                    elif "Execute" in edge.action: tactic = ATTACKTactic.EXECUTION
                    elif "Reuse" in edge.action: tactic = ATTACKTactic.CREDENTIAL_ACCESS
                    elif "Steal" in edge.action: tactic = ATTACKTactic.CREDENTIAL_ACCESS
                    elif "Login" in edge.action: tactic = ATTACKTactic.INITIAL_ACCESS
                    elif "Access" in edge.action: tactic = ATTACKTactic.COLLECTION

                    step = AttackStep(
                        tactic=tactic,
                        technique=edge.action,
                        description=f"Action: {edge.action} from {edge.source_id}",
                        success=True # Potential success
                    )
                    chain.steps.append(step)
                
                chain.impact_score = 10.0 # Reached objective
                found_paths = True
                break 
                
        if not found_paths:
             debug_print(f"      Reference: No complete attack paths found.")
        
        return chain

    def _calculate_path_prob(self, path: List[AttackEdge]) -> float:
        prob = 1.0
        for edge in path:
            prob *= edge.probability
        return prob

    def get_chain_summary(self, chain: ExploitationChain) -> Dict[str, Any]:
        """Get summary of exploitation chain"""
        return {
            "target": chain.target.hostname or chain.target.ip,
            "steps_completed": len(chain.steps),
            "total_steps": len(chain.steps),
            "impact_score": chain.impact_score,
            "credentials_extracted": len(chain.credentials_extracted),
            "hosts_compromised": len(chain.compromised_hosts),
            "data_exfiltrated": len(chain.data_exfiltrated),
            "tactics": [s.tactic.value for s in chain.steps]
        }
