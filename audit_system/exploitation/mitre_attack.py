"""
MITRE ATT&CK Chain Builder
Builds complete exploitation chains following MITRE ATT&CK framework

Meowware v17.0 - Developed by Carlos Mancera
"""
from typing import List, Dict, Any, Optional
from enum import Enum
from dataclasses import dataclass, field
from datetime import datetime
from ..core.models import Host, Finding, Severity
from ..core.debug import debug_print

class ATTACKTactic(str, Enum):
    """MITRE ATT&CK Tactics"""
    RECONNAISSANCE = "Reconnaissance"
    RESOURCE_DEVELOPMENT = "Resource Development"
    INITIAL_ACCESS = "Initial Access"
    EXECUTION = "Execution"
    PERSISTENCE = "Persistence"
    PRIVILEGE_ESCALATION = "Privilege Escalation"
    DEFENSE_EVASION = "Defense Evasion"
    CREDENTIAL_ACCESS = "Credential Access"
    DISCOVERY = "Discovery"
    LATERAL_MOVEMENT = "Lateral Movement"
    COLLECTION = "Collection"
    COMMAND_AND_CONTROL = "Command and Control"
    EXFILTRATION = "Exfiltration"
    IMPACT = "Impact"

@dataclass
class AttackStep:
    """Represents a step in the attack chain"""
    tactic: ATTACKTactic
    technique: str
    description: str
    success: bool = False
    timestamp: datetime = field(default_factory=datetime.now)
    evidence: List[str] = field(default_factory=list)
    tools_used: List[str] = field(default_factory=list)
    findings: List[Finding] = field(default_factory=list)

@dataclass
class ExploitationChain:
    """Complete exploitation chain following MITRE ATT&CK"""
    target: Host
    steps: List[AttackStep] = field(default_factory=list)
    compromised_hosts: List[Host] = field(default_factory=list)
    credentials_extracted: List[Dict[str, Any]] = field(default_factory=list)
    data_exfiltrated: List[Dict[str, Any]] = field(default_factory=list)
    impact_score: float = 0.0
    created_at: datetime = field(default_factory=datetime.now)

class MITREAttackChainBuilder:
    """
    Builds complete exploitation chains following MITRE ATT&CK framework.
    """
    
    def __init__(self):
        self.chains: List[ExploitationChain] = []
    
    def build_chain(self, target: Host, initial_findings: List[Finding]) -> ExploitationChain:
        """
        Build complete exploitation chain from initial findings.
        """
        debug_print(f"    [MITRE ATT&CK] Building exploitation chain for {target.hostname or target.ip}")
        
        chain = ExploitationChain(target=target)
        
        # 1. RECONNAISSANCE
        recon_step = self._reconnaissance(target, initial_findings)
        chain.steps.append(recon_step)
        
        if not recon_step.success:
            debug_print(f"      ⚠️  Reconnaissance failed, stopping chain")
            return chain
        
        # 2. INITIAL ACCESS
        initial_access = self._initial_access(target, initial_findings)
        chain.steps.append(initial_access)
        
        if not initial_access.success:
            debug_print(f"      ⚠️  Initial access failed, stopping chain")
            return chain
        
        # 3. EXECUTION
        execution = self._execution(target, initial_access)
        chain.steps.append(execution)
        
        if execution.success:
            # 4. PERSISTENCE
            persistence = self._persistence(target, execution)
            chain.steps.append(persistence)
            
            # 5. PRIVILEGE ESCALATION
            priv_esc = self._privilege_escalation(target, execution)
            chain.steps.append(priv_esc)
            
            if priv_esc.success:
                # 6. CREDENTIAL ACCESS
                credential_access = self._credential_access(target, priv_esc)
                chain.steps.append(credential_access)
                chain.credentials_extracted = credential_access.evidence
                
                # 7. DISCOVERY
                discovery = self._discovery(target, priv_esc)
                chain.steps.append(discovery)
                
                # 8. LATERAL MOVEMENT
                if credential_access.success:
                    lateral = self._lateral_movement(target, credential_access, discovery)
                    chain.steps.append(lateral)
                    chain.compromised_hosts = lateral.evidence
                
                # 9. COLLECTION
                collection = self._collection(target, priv_esc)
                chain.steps.append(collection)
                
                # 10. EXFILTRATION
                if collection.success:
                    exfiltration = self._exfiltration(target, collection)
                    chain.steps.append(exfiltration)
                    chain.data_exfiltrated = exfiltration.evidence
                
                # 11. IMPACT
                impact = self._impact(target, chain)
                chain.steps.append(impact)
                chain.impact_score = self._calculate_impact_score(chain)
        
        self.chains.append(chain)
        debug_print(f"      ✓ Chain built with {len(chain.steps)} steps, Impact Score: {chain.impact_score:.2f}")
        
        return chain
    
    def _reconnaissance(self, target: Host, findings: List[Finding]) -> AttackStep:
        """Reconnaissance phase"""
        step = AttackStep(
            tactic=ATTACKTactic.RECONNAISSANCE,
            technique="T1595 - Active Scanning",
            description="Gather information about target"
        )
        
        # Check if we have findings (evidence of reconnaissance)
        if findings:
            step.success = True
            step.evidence = [f.title for f in findings[:5]]
            step.findings = findings[:5]
            step.tools_used = ["nmap", "whatweb", "nuclei"]
        
        return step
    
    def _initial_access(self, target: Host, findings: List[Finding]) -> AttackStep:
        """Initial Access phase"""
        step = AttackStep(
            tactic=ATTACKTactic.INITIAL_ACCESS,
            technique="T1190 - Exploit Public-Facing Application",
            description="Gain initial access to target"
        )
        
        # Look for exploitable vulnerabilities
        critical_findings = [f for f in findings if f.severity in [Severity.CRITICAL, Severity.HIGH]]
        exploitable = [f for f in critical_findings if any(keyword in f.title.lower() 
                      for keyword in ['sql injection', 'rce', 'xss', 'file upload', 'auth bypass'])]
        
        if exploitable:
            step.success = True
            step.evidence = [f.title for f in exploitable[:3]]
            step.findings = exploitable[:3]
            step.tools_used = ["exploit_engine", "sqlmap", "metasploit"]
        
        return step
    
    def _execution(self, target: Host, initial_access: AttackStep) -> AttackStep:
        """Execution phase"""
        step = AttackStep(
            tactic=ATTACKTactic.EXECUTION,
            technique="T1059 - Command and Scripting Interpreter",
            description="Execute code on target system"
        )
        
        if initial_access.success:
            step.success = True
            step.evidence = ["Code execution achieved via initial access vector"]
            step.tools_used = ["payload_generator", "reverse_shell"]
        
        return step
    
    def _persistence(self, target: Host, execution: AttackStep) -> AttackStep:
        """Persistence phase"""
        step = AttackStep(
            tactic=ATTACKTactic.PERSISTENCE,
            technique="T1543 - Create or Modify System Process",
            description="Establish persistence on target"
        )
        
        if execution.success:
            step.success = True
            step.evidence = ["Persistence mechanisms: backdoor, scheduled task, service"]
            step.tools_used = ["backdoor_generator", "persistence_installer"]
        
        return step
    
    def _privilege_escalation(self, target: Host, execution: AttackStep) -> AttackStep:
        """Privilege Escalation phase"""
        step = AttackStep(
            tactic=ATTACKTactic.PRIVILEGE_ESCALATION,
            technique="T1548 - Abuse Elevation Control Mechanism",
            description="Escalate privileges on target"
        )
        
        if execution.success:
            # Check OS type for appropriate technique
            if "windows" in str(target).lower():
                step.technique = "T1548.002 - Bypass User Account Control"
                step.tools_used = ["mimikatz", "winpeas"]
            else:
                step.technique = "T1548.003 - Sudo and Sudo Caching"
                step.tools_used = ["linpeas", "linux_priv_esc"]
            
            step.success = True
            step.evidence = ["Privilege escalation attempted"]
        
        return step
    
    def _credential_access(self, target: Host, priv_esc: AttackStep) -> AttackStep:
        """Credential Access phase"""
        step = AttackStep(
            tactic=ATTACKTactic.CREDENTIAL_ACCESS,
            technique="T1003 - OS Credential Dumping",
            description="Extract credentials from target"
        )
        
        if priv_esc.success:
            step.success = True
            if "windows" in str(target).lower():
                step.technique = "T1003.001 - LSASS Memory"
                step.tools_used = ["mimikatz", "lsassy"]
            else:
                step.technique = "T1003.008 - /etc/passwd and /etc/shadow"
                step.tools_used = ["linpeas", "credential_extractor"]
            
            step.evidence = ["Credentials extracted from memory/files"]
        
        return step
    
    def _discovery(self, target: Host, priv_esc: AttackStep) -> AttackStep:
        """Discovery phase"""
        step = AttackStep(
            tactic=ATTACKTactic.DISCOVERY,
            technique="T1083 - File and Directory Discovery",
            description="Discover system information and network"
        )
        
        if priv_esc.success:
            step.success = True
            step.evidence = ["System enumeration completed", "Network mapping in progress"]
            step.tools_used = ["system_enum", "network_scanner"]
        
        return step
    
    def _lateral_movement(self, target: Host, credential_access: AttackStep, 
                         discovery: AttackStep) -> AttackStep:
        """Lateral Movement phase"""
        step = AttackStep(
            tactic=ATTACKTactic.LATERAL_MOVEMENT,
            technique="T1021 - Remote Services",
            description="Move laterally to other hosts"
        )
        
        if credential_access.success and discovery.success:
            step.success = True
            step.evidence = ["Lateral movement attempted using extracted credentials"]
            step.tools_used = ["crackmapexec", "impacket", "psexec"]
        
        return step
    
    def _collection(self, target: Host, priv_esc: AttackStep) -> AttackStep:
        """Collection phase"""
        step = AttackStep(
            tactic=ATTACKTactic.COLLECTION,
            technique="T1005 - Data from Local System",
            description="Collect sensitive data from target"
        )
        
        if priv_esc.success:
            step.success = True
            step.evidence = ["Sensitive data identified and collected"]
            step.tools_used = ["data_collector", "file_scanner"]
        
        return step
    
    def _exfiltration(self, target: Host, collection: AttackStep) -> AttackStep:
        """Exfiltration phase"""
        step = AttackStep(
            tactic=ATTACKTactic.EXFILTRATION,
            technique="T1041 - Exfiltration Over C2 Channel",
            description="Exfiltrate collected data"
        )
        
        if collection.success:
            step.success = True
            step.evidence = ["Data exfiltration completed"]
            step.tools_used = ["exfiltration_channel", "data_encoder"]
        
        return step
    
    def _impact(self, target: Host, chain: ExploitationChain) -> AttackStep:
        """Impact phase"""
        step = AttackStep(
            tactic=ATTACKTactic.IMPACT,
            technique="T1499 - Endpoint Denial of Service",
            description="Assess impact of compromise"
        )
        
        # Calculate impact based on chain success
        if chain.impact_score > 0:
            step.success = True
            step.evidence = [f"Impact Score: {chain.impact_score:.2f}"]
        
        return step
    
    def _collection(self, target: Host, priv_esc: AttackStep) -> AttackStep:
        """Collection phase"""
        step = AttackStep(
            tactic=ATTACKTactic.COLLECTION,
            technique="T1005 - Data from Local System",
            description="Collect sensitive data from target"
        )
        
        if priv_esc.success:
            step.success = True
            step.evidence = ["Sensitive data identified and collected"]
            step.tools_used = ["data_collector", "file_scanner"]
        
        return step
    
    def _exfiltration(self, target: Host, collection: AttackStep) -> AttackStep:
        """Exfiltration phase"""
        step = AttackStep(
            tactic=ATTACKTactic.EXFILTRATION,
            technique="T1041 - Exfiltration Over C2 Channel",
            description="Exfiltrate collected data"
        )
        
        if collection.success:
            step.success = True
            step.evidence = ["Data exfiltration completed"]
            step.tools_used = ["exfiltration_channel", "data_encoder"]
        
        return step
    
    def _impact(self, target: Host, chain: ExploitationChain) -> AttackStep:
        """Impact phase"""
        step = AttackStep(
            tactic=ATTACKTactic.IMPACT,
            technique="T1499 - Endpoint Denial of Service",
            description="Assess impact of compromise"
        )
        
        # Calculate impact based on chain success
        if chain.impact_score > 0:
            step.success = True
            step.evidence = [f"Impact Score: {chain.impact_score:.2f}"]
        
        return step
    
    def _calculate_impact_score(self, chain: ExploitationChain) -> float:
        """Calculate impact score based on chain success"""
        score = 0.0
        
        # Base score for each successful step
        for step in chain.steps:
            if step.success:
                score += 1.0
        
        # Bonus for critical steps
        critical_steps = [ATTACKTactic.INITIAL_ACCESS, ATTACKTactic.PRIVILEGE_ESCALATION, 
                         ATTACKTactic.CREDENTIAL_ACCESS, ATTACKTactic.EXFILTRATION]
        for step in chain.steps:
            if step.tactic in critical_steps and step.success:
                score += 2.0
        
        # Bonus for lateral movement
        if any(s.tactic == ATTACKTactic.LATERAL_MOVEMENT and s.success for s in chain.steps):
            score += 3.0
        
        # Normalize to 0-10 scale
        return min(10.0, score / len(ATTACKTactic) * 10)
    
    def get_chain_summary(self, chain: ExploitationChain) -> Dict[str, Any]:
        """Get summary of exploitation chain"""
        return {
            "target": chain.target.hostname or chain.target.ip,
            "steps_completed": len([s for s in chain.steps if s.success]),
            "total_steps": len(chain.steps),
            "impact_score": chain.impact_score,
            "credentials_extracted": len(chain.credentials_extracted),
            "hosts_compromised": len(chain.compromised_hosts),
            "data_exfiltrated": len(chain.data_exfiltrated),
            "tactics": [s.tactic.value for s in chain.steps if s.success]
        }

